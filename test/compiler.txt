flip = \f.\x.\y.f y x
curry = \f.\a1.\a2.f (T a1 a2)

add = curry $add
sub = curry $sub
mult = curry $mult
concat = curry $concat
index = curry $index
subString = \s.\start.\length.$subString(T3 s start length)
intSlt = curry $intSlt
intSle = curry $intSle
writeRef = curry $writeRef

const = \a.\b.a
ignore = \a.\b.b

intEq = \i1.\i2.\vt.\vf.(\0.vf|1.vt)($intEq(T i1 i2))
#intEqTF = \i1.\i2.$intEq(Q i1 i2 True False)
intLteq = \i1.\i2.\vt.\vf.(\0.vf|1.vt)(intSle i1 i2)
succ = add 1
#toList = \s.$fix \rec.\i.(\True.Nil|False.Cons (index s i) (rec(succ i)))(intEqTF i ($strLen s))

isInRange = \start.\end.\c.\t.\f.intLteq ($ord start) ($ord c) (intLteq ($ord c) ($ord end) t f) f
isDigit = isInRange '0' '9'
mkTF = \f.\c.f c True False
isDigitTF = mkTF isDigit
isLower = isInRange 'a' 'z'
isLowerTF = mkTF isLower
isUpper = isInRange 'A' 'Z'
isUpperTF = mkTF isUpper
id = \x.x
or = \True.const True|False.id
isAlphaNum = \c.or (isUpperTF c) (or (isLowerTF c) (isDigitTF c))
isNotQuote = \'"'.(\t.\f.f)|_.(\t.\f.t)

scan = \s.\pred.$fix\rec.\i.pred(index s i)(\_.rec(succ i))(\_.i)U
strfoldl = \f.\s.$fix\rec.\acc.\i.intEq i ($strLen s) (\_.acc)(\_.rec (f acc (index s i)) (succ i)) U
foldl = \f.$fix\rec.\acc.\Nil.acc|Cons x xs.rec (f acc x) xs
stringToInt = \s.strfoldl (\cur.\char.add (mult 10 cur) (sub ($ord char) ($ord '0'))) s 0 0
#peek = \s.\i.intLt i ($strLen s) (Some (index s i)) (None)
pconstant = \s.\i.(\'"'.Just(CString(subString s (succ i) (sub (scan s isNotQuote (succ i))1)))|'\''.Just(CChar('X'))|c."fail")(index s i)
seq = \p1.\p2.\comb.\s.(\None.None|Some v1.(\None.None|Some v2.Some(comb v1 v2))(p2 s))(p1 s)
mapMaybe = \f.\None.None|Some x.Some(f x)
min = \x.\y.(\1.x|0.y)(intSlt x y)
max = \x.\y.(\1.y|0.x)(intSlt x y)

mkStream = \s.Stream s ($newRef 0)
isAtEOF = \Stream s iRef.intEq ($strLen s) ($readRef iRef) "t" "f"
tryGetCurChar = \Stream s iRef.(\i.(\1.Some(index s i)|0.None)(intSlt i ($strLen s)))($readRef iRef)
modify = \f.\ref.writeRef ref (f ($readRef ref))
advance = \n.\Stream _ iRef.modify (add n) iRef
getIndex = \Stream _ iRef.$readRef iRef
getString = \Stream s _.s
tryGetNext = \s.(\None.None|Some c.const (Some c) (advance 1 s))(tryGetCurChar s)
pany = \s.(\None.None|Some c.const (Some c) (advance 1 s))(tryGetCurChar s)
ppred = \pred.\s.(\None.None|Some c.(pred c)(\_.ignore (advance 1 s) (Some c)) (\_.None) U) (tryGetCurChar s)
#digits = \s.$fix\r.\_.(\None.getIndex s|Some c.isDigit c(\_.const(advance 1) (r U))(\_.getIndex s)U)(tryGetCurChar s) U
many = \p.\s.Some(($fix\r.\_.(\None.None|Some v.Cons v (r U))(p s))U)
manyI = \pred.\s.Some(($fix\r.\start.(\Some True.ignore(advance 1 s)(r start)|_.subString (getString s) start (sub (getIndex s) 1))(mapMaybe pred (tryGetCurChar s)))(getIndex s))
manyI = \pred.\s.Some(($fix\r.\_.(\Some True.ignore(advance 1 s)(r U)|_.sub (getIndex s) 1)(mapMaybe pred (tryGetCurChar s)))U)
pred1 = \pred.\s.(\Some True.Some(advance 1 s)|_.None)(mapMaybe pred (tryGetCurChar s))
predCh = \pred.\s.mapMaybe(\i.index (getString s)(sub i 1))(pred1 pred s)
manyNO = \p.\s.($fix\r.\start.(\None.T start (getIndex s)|Some v.r start)(p s))(getIndex s)
manyString = \p.\s.($fix\r.\start.(\None.Some(subString (getString s) start (getIndex s))|Some _.r start)(p s))(getIndex s)
manyPred = \pred.manyString(ppred pred)
pdigit = ppred isDigit
digits = \s.($fix\r.\start.(\Some True.ignore (advance 1 s) (r start)|_.Some(subString (getString s) start (getIndex s)))(mapMaybe isDigitTF (tryGetCurChar s)))(getIndex s)
# parse predicate many times, returning substring
#ppredN = \pred.\s.$fix\r.\u.(\None.getIndex s|Some c.(pred c)(\_.const (advance 1) (r U))(\_.getIndex s)) (tryGetCurChar s)
_ = scan "2134 b" isDigit 0
_ = strfoldl (flip Cons) "Se" Nil 0
_ = stringToInt "1234"
#_ = foldl (flip Cons) Nil (Cons 'a' (Cons 'b' Nil))
_ = L (pconstant "\"abc\"" 0) (pconstant "'a'" 0) (pconstant "1234" 0)
stream = mkStream "a4"
wordCont = \firstPred.\followPred.\f.\s.seq (pred1 firstPred) (manyI followPred) f s
word = \firstPred.\followPred.\s.seq (pred1 firstPred) (manyI followPred) (\fc.\l.subString (getString s) (sub fc 1) (add l 1)) s
#_ = L (tryGetCurChar stream) (advance stream) (tryGetCurChar stream) (advance stream) (tryGetCurChar stream) (isAtEOF stream)
#parser = \s.\before.(seq pdigit (manyI isDigitTF) (\fc.\l.subString before (add before l) (getIndex s)) s) (getIndex s) s
pmap = \f.\p.\s.mapMaybe f (p s)
choice = \p1.\p2.\s.(\None.p2 s|Some v1.v1)(p1 s)
upperId = word isUpperTF isAlphaNum
lowerId = word isLowerTF isAlphaNum
decimal = word isDigitTF isDigitTF
qstring = \s.wordCont (\'\"'.True|_.False) (\'\"'.False|_.True) (\fc.\l.subString (getString s) fc l) s
singleQ = pred1 (\'''.True|_.False)
qchar = seq singleQ (seq (predCh (const True)) singleQ const) ignore
parser = choice (pmap (\s.CInt(stringToInt s)) decimal) (choice (pmap CAtom upperId) (choice (pmap CString qstring) (pmap CChar qchar)))
p = \str.parser (mkStream str)
_ = L (p "") (p "Has") (p "A") (p "LAAR34 ") (p "34") (p "\"abc\"") (p "'a'")

