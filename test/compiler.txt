# compiler
id = \x.x
const = \a.\b.a
ignore = \a.\b.b
flip = \f.\x.\y.f y x
curry = \f.\a1.\a2.f (T a1 a2)

add = curry $add
sub = curry $sub
mult = curry $mult
index = curry $index
subString = \s.\start.\length.$subString(T3 s start length)
intSlt = curry $intSlt
intSle = curry $intSle
writeRef = curry $writeRef

intEq = \i1.\i2.\vt.\vf.(\0.vf|1.vt)($intEq(T i1 i2))
intLteq = \i1.\i2.\vt.\vf.(\0.vf|1.vt)(intSle i1 i2)
succ = add 1

isInRange = \start.\end.\c.\t.\f.intLteq ($ord start) ($ord c) (intLteq ($ord c) ($ord end) t f) f
isDigit = isInRange '0' '9'
mkTF = \f.\c.f c True False
isDigitTF = mkTF isDigit
isLower = isInRange 'a' 'z'
isLowerTF = mkTF isLower
isUpper = isInRange 'A' 'Z'
isUpperTF = mkTF isUpper
or = \True.const True|False.id
isAlphaNum = \c.or (isUpperTF c) (or (isLowerTF c) (isDigitTF c))
isNotQuote = \'"'.(\t.\f.f)|_.(\t.\f.t)

scan = \s.\pred.$fix\rec.\i.pred(index s i)(\_.rec(succ i))(\_.i)U
strfoldl = \f.\s.$fix\rec.\acc.\i.intEq i ($strLen s) (\_.acc)(\_.rec (f acc (index s i)) (succ i)) U
foldl = \f.$fix\rec.\acc.\Nil.acc|Cons x xs.rec (f acc x) xs
foldl1 = \f.\Cons x xs.foldl f x xs
stringToInt = \s.strfoldl (\cur.\char.add (mult 10 cur) (sub ($ord char) ($ord '0'))) s 0 0
mapMaybe = \f.\None.None|Some x.Some(f x)
seq = \p1.\p2.\comb.\s.(\None.None|Some v1.(\None.None|Some v2.Some(comb v1 v2))(p2 s))(p1 s)
choice = \p1.\p2.\s.(\None.p2 s|sv1.sv1)(p1 s)
between = \first.\middle.\end.seq first (seq middle end const) ignore
pmap = \f.\p.\s.mapMaybe f (p s)


mkStream = \s.Stream s ($newRef 0)
tryGetCurChar = \Stream s iRef.(\i.(\1.Some(index s i)|0.None)(intSlt i ($strLen s)))($readRef iRef)
modify = \f.\ref.writeRef ref (f ($readRef ref))
advance = \n.\Stream _ iRef.modify (add n) iRef
getIndex = \Stream _ iRef.$readRef iRef
getString = \Stream s _.s

mkRec = $fix\rec.\recCtor.\s.(\p.p s)(recCtor (\_.rec recCtor))
many = \p.mkRec\rec.choice (seq p (rec U) Cons) (const (Some Nil))
many1 = \p.seq p (many p) Cons
sepBy1 = \p.\sep.seq p (many (seq sep p ignore)) Cons
pcomb = \ctor.\p.pmap(\l.foldl1 ctor l)(many1 p)

manyI = \pred.\s.Some(($fix\r.\_.(\Some True.ignore(advance 1 s)(r U)|_.getIndex s)(mapMaybe pred (tryGetCurChar s)))U)
pred1 = \pred.\s.(\Some True.Some(advance 1 s)|_.None)(mapMaybe pred (tryGetCurChar s))
predCh = \pred.\s.mapMaybe(\i.index (getString s)(sub i 1))(pred1 pred s)
wordCont = \firstPred.\followPred.\f.\s.seq (pred1 firstPred) (manyI followPred) f s
word = \firstPred.\followPred.\s.seq (pred1 firstPred) (manyI followPred) (\fc.\e.subString (getString s) (sub fc 1) (add 1 (sub e fc))) s
upperId = word isUpperTF isAlphaNum
lowerId = word isLowerTF isAlphaNum
decimal = pmap stringToInt (word isDigitTF isDigitTF)
qstring = \s.wordCont (\'\"'.True|_.False) (\'\"'.False|_.True) (\fc.\l.subString (getString s) fc l) s
pprim = word (\'$'.True|_.False) isAlphaNum
char = \c.pred1(\pc.intEq($ord pc)($ord c) True False)
lex = \p.seq (manyI (\' '.True|_.False)) p ignore
ch = \c.lex (char c)
betweenCh = \c1.\p.\c2.between (ch c1) p (ch c2)
qchar = betweenCh ''' (predCh (const True)) '''
pconst = choice (pmap (\s.CInt s) decimal) (choice (pmap CAtom upperId) (choice (pmap CString qstring) (pmap CChar qchar)))
parens = \p.betweenCh '(' p ')'
ppatternAtom = choice (pmap (const PWildcard) (char '_')) (choice (pmap PConstant pconst) (pmap PVariable lowerId))
ppattern1 = mkRec\rec.choice ppatternAtom (pmap PParenthesis (parens (rec U)))
ppattern = pcomb PApply ppattern1
pexpAtom = choice (pmap EConstant pconst) (choice (pmap EVariable lowerId) (pmap EPrim pprim))
pexp1 = mkRec\rec.choice pexpAtom (choice (pmap EParenthesis (parens (rec U))) (pmap ELambda (seq (ch '\\') (sepBy1 (seq ppattern (seq (ch '.') (rec U) ignore) T) (ch '|')) ignore)))
pexp = pcomb EApply pexp1
parser = pexp
p = \str.parser (mkStream str)
_ = L (p "f x") (p "((x))") (p "(xyz)") (p "()") (p "x)") (p "xyz)") (p "x))") (p "$eq") (p "Nil") (p "\\Some x.x")
