id = \x.x
const = \a.\b.a
ignore = \a.\b.b
flip = \f.\x.\y.f y x
curry = \f.\a1.\a2.f (T a1 a2)

add = curry $add
sub = curry $sub
mult = curry $mult
index = curry $index
subString = \s.\start.\length.$subString(T3 s start length)
intSlt = curry $intSlt
intSle = curry $intSle
intEq = curry $intEq
writeRef = curry $writeRef

intEq = \i1.\i2.(\0.False|1.True)(intEq i1 i2)
intLteq = \i1.\i2.(\0.False|1.True)(intSle i1 i2)

or = \True.const True|False.id
and = \False.const False|True.id

isInRange = \start.\end.\c.and(intLteq ($ord start) ($ord c)) (intLteq ($ord c) ($ord end))
isDigit = isInRange '0' '9'
isLower = isInRange 'a' 'z'
isUpper = isInRange 'A' 'Z'
isAlphaNum = \c.or (isUpper c) (or (isLower c) (isDigit c))

strfoldl = \f.\s.$fix\rec.\acc.\i.(\True.acc|False.rec (f acc (index s i)) (add 1 i))(intEq i ($strLen s))
foldl = \f.$fix\rec.\acc.\Nil.acc|Cons x xs.rec (f acc x) xs
foldl1 = \f.\Cons x xs.foldl f x xs
stringToInt = \s.strfoldl (\cur.\char.add (mult 10 cur) (sub ($ord char) ($ord '0'))) s 0 0
mapMaybe = \f.\None.None|Some x.Some(f x)
seq = \p1.\p2.\comb.\s.(\None.None|Some v1.(\None.None|Some v2.Some(comb v1 v2))(p2 s))(p1 s)
choice = \p1.\p2.\s.(\None.p2 s|sv1.sv1)(p1 s)

pfst = \p1.\p2.seq p1 p2 const
psnd = \p1.\p2.seq p1 p2 ignore
between = \first.\middle.\end.psnd first (pfst middle end)
pmap = \f.\p.\s.mapMaybe f (p s)

mkStream = \s.Stream s ($newRef 0)
tryGetCurChar = \Stream s iRef.(\i.(\1.Some(index s i)|0.None)(intSlt i ($strLen s)))($readRef iRef)
modify = \f.\ref.writeRef ref (f ($readRef ref))
advance = \Stream _ iRef.modify (add 1) iRef
getIndex = \Stream _ iRef.$readRef iRef
getString = \Stream s _.s

mkRec = $fix\rec.\recCtor.\s.(\p.p s)(recCtor (\_.rec recCtor))
many = \p.mkRec\rec.choice (seq p (rec U) Cons) (const (Some Nil))
many1 = \p.seq p (many p) Cons
sepBy1 = \p.\sep.seq p (many (psnd sep p)) Cons
pcomb = \ctor.\p.pmap(\l.foldl1 ctor l)(many1 p)

manyI = \pred.\s.Some(($fix\r.\_.(\Some True.ignore(advance s)(r U)|_.getIndex s)(mapMaybe pred (tryGetCurChar s)))U)
pred1 = \pred.\s.(\Some True.Some(advance s)|_.None)(mapMaybe pred (tryGetCurChar s))
predCh = \pred.\s.mapMaybe(\i.index (getString s)(sub i 1))(pred1 pred s)
word = \firstPred.\followPred.\s.seq (pred1 firstPred) (manyI followPred) (\fc.\e.subString (getString s) (sub fc 1) (add 1 (sub e fc))) s
manyPred = \pred.\s.(\start.$fix\r.\_.(\Some True.ignore(advance s)(r U)|_.Some (T start (getIndex s)))(mapMaybe pred (tryGetCurChar s)))(getIndex s) U
upperId = word isUpper isAlphaNum
lowerId = word isLower isAlphaNum
word1 = \p.word p p
char = \c.pred1(\pc.intEq($ord pc)($ord c))
comment = seq (pred1 (\'#'.True|_.False)) (manyPred (\'\n'.False|_.True)) T
space = seq (manyI (\' '.True|_.False)) (many comment) T
lex = \p.psnd space p
decimal = lex (pmap stringToInt (word1 isDigit))
qstring = between (char '\"') (manyPred (\'\"'.False|_.True)) (char '\"')
pprim = psnd (char '$') (word1 isAlphaNum)
ch = \c.lex (char c)
betweenCh = \c1.\p.\c2.between (ch c1) p (ch c2)
parens = \p.betweenCh '(' p ')'
qchar = between (char ''') (predCh (const True)) (char ''')
pconst = choice (pmap (\s.CInt s) decimal) (choice (pmap CAtom upperId) (choice (pmap CString qstring) (pmap CChar qchar)))
ppatternAtom = choice (pmap (const PWildcard) (ch '_')) (choice (pmap PConstant pconst) (pmap PVariable lowerId))
ppattern1 = mkRec\rec.choice ppatternAtom (pmap PParenthesis (parens (rec U)))
ppattern = pcomb PApply ppattern1
pexpAtom = choice (pmap EConstant pconst) (choice (pmap EVariable lowerId) (pmap EPrim pprim))
pexp = mkRec\rec.pcomb EApply (choice pexpAtom (choice (pmap EParenthesis (parens (rec U))) (pmap ELambda (psnd (ch '\\') (sepBy1 (seq ppattern (psnd (ch '.') (rec U)) T) (ch '|'))))))
pdecl = seq ppattern (psnd (ch '=') pexp) Decl
pdecls = sepBy1 pdecl (many1 (seq (many comment) (char '\n') T))

parser = pdecls
p = \str.parser (mkStream str)
#_ = L (p "f x") (p "((x))") (p "(xyz)") (p "()") (p "x)") (p "xyz)") (p "x))") (p "$eq") (p "Nil") (p "\\Some x.x")
_ = L (p "x = f # 5\n#y = f 5\nz=5")
